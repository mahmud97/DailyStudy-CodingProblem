Task : 
Task asynchronously kaj kore 
Why we need Tasks? It can be used whenever you want to execute something in parallel. Asynchronous implementation is easy in a task, using’ async’ and ‘await’ keywords.

Differences Between Task And Thread

The task can return a result. There is no direct mechanism to return the result from a thread.
Task supports cancellation through the use of cancellation tokens. But Thread doesn't.
A task can have multiple processes happening at the same time. Threads can only have one task running at a time.
We can easily implement Asynchronous using ’async’ and ‘await’ keywords.
A new Thread()is not dealing with Thread pool thread, whereas Task does use thread pool thread.
A Task is a higher level concept than Thread.


Partial classes:
Partial classes span multiple files.With normal C# classes, you cannot declare a class in two separate files in the same project. But with the partial modifier, you can.
for example :ABC project a ABCDBContext same name a 2 ta partial class ase 

Virtual Keyword : 
In c#, the virtual keyword is useful to override base class members such as properties, methods, etc. in the derived class to modify it based on our requirements.
In c#, by default all the methods are non-virtual and we cannot override non-virtual methods. In case, if you want to override a method, then you need to define it with the virtual keyword.

 
AutoMapper:
sohoj basai automapper diye ak type ar object ke arek type ar object a convert kori 
How do I use AutoMapper?

First, you need both a source and destination type to work with.
var config = new MapperConfiguration(cfg => cfg.CreateMap<Order, OrderDto>());

secondly To perform a mapping, call one of the Map overloads:
var mapper = config.CreateMapper();
// or
var mapper = new Mapper(config);
OrderDto dto = mapper.Map<OrderDto>(order);

T:
What does <T> denote in C# ?

A generic type parameter allows you to specify an arbitrary type T to a method at compile-time, without specifying a concrete type in the method or class declaration.
public T[] Reverse<T>(T[] array)
{
    var result = new T[array.Length];
    int j=0;
    for(int i=array.Length - 1; i>= 0; i--)
    {
        result[j] = array[i];
        j++;
    }
    return result;
}
The key point here is that the array elements can be of any type, and the function will still work. You specify the type in the method call; type safety is still guaranteed.






